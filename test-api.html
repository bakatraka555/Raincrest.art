<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Upload Your Photo - Raincrest Art</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Inter:wght@400;500;600&display=swap"
        rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            min-height: 100vh;
            padding: 40px 20px;
            color: #f5f5f5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: #141414;
            border-radius: 20px;
            padding: 40px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #c9a227;
            font-family: 'Cinzel', serif;
        }

        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 40px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #c9a227;
        }

        input[type="file"],
        input[type="text"],
        select {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(201, 162, 39, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            font-size: 16px;
        }

        input[type="file"]:hover,
        input[type="text"]:hover,
        select:hover {
            border-color: #c9a227;
        }

        button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #8b7019 0%, #c9a227 50%, #e8c547 100%);
            color: #0a0a0a;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Cinzel', serif;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(201, 162, 39, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .preview {
            margin: 20px 0;
            text-align: center;
        }

        .preview img {
            max-width: 300px;
            max-height: 300px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .result {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid rgba(0, 255, 0, 0.3);
            border-radius: 10px;
            display: none;
        }

        .result.show {
            display: block;
        }

        .result.error {
            background: rgba(255, 0, 0, 0.1);
            border-color: rgba(255, 0, 0, 0.3);
        }

        .result img {
            max-width: 100%;
            border-radius: 10px;
            margin-top: 15px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(201, 162, 39, 0.2);
            border-top: 4px solid #c9a227;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            margin: 0 auto 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .api-select {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
        }

        .api-option {
            flex: 1;
            padding: 15px;
            text-align: center;
            border: 2px solid rgba(201, 162, 39, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .api-option:hover {
            border-color: #c9a227;
        }

        .api-option.selected {
            border-color: #c9a227;
            background: rgba(201, 162, 39, 0.1);
        }

        .api-label {
            font-weight: 600;
        }

        .api-desc {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .log {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .container {
                padding: 20px;
                border-radius: 16px;
            }

            h1 {
                font-size: 22px;
            }

            .subtitle {
                font-size: 14px;
                margin-bottom: 25px;
            }

            .api-select {
                flex-direction: column;
                gap: 10px;
            }

            .api-option {
                padding: 12px;
            }

            .form-group {
                margin-bottom: 20px;
            }

            label {
                font-size: 14px;
            }

            input[type="file"],
            input[type="text"],
            select {
                padding: 12px;
                font-size: 14px;
            }

            button {
                padding: 14px;
                font-size: 16px;
            }

            .preview img {
                max-width: 100%;
                max-height: 250px;
            }

            .result img {
                max-width: 100%;
            }

            .log {
                font-size: 11px;
                max-height: 150px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 16px;
            }

            h1 {
                font-size: 20px;
            }

            .gender-select {
                flex-direction: column;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üß™ API Test</h1>
        <p class="subtitle">Compare Replicate vs Google Gemini</p>

        <!-- API Selection -->
        <div class="api-select">
            <div class="api-option selected" data-api="replicate">
                <div class="api-label">Replicate</div>
                <div class="api-desc">Image (nano-banana)</div>
            </div>
            <div class="api-option" data-api="gemini">
                <div class="api-label">Gemini</div>
                <div class="api-desc">Image (gemini-3)</div>
            </div>
            <div class="api-option" data-api="veo">
                <div class="api-label">üé¨ Veo 3.1</div>
                <div class="api-desc">VIDEO (5 sec)</div>
            </div>
        </div>

        <!-- Image Upload -->
        <div class="form-group">
            <label>üì∏ Select Image</label>
            <input type="file" id="imageInput" accept="image/*">
        </div>

        <div class="preview" id="preview" style="display: none;">
            <img id="previewImg" alt="Preview">
        </div>

        <!-- Template -->
        <div class="form-group">
            <label>üé≠ Template</label>
            <select id="templateSelect">
                <option value="template-01">Trading Card (King & Queen)</option>
                <option value="template-02">Dragon Rider</option>
                <option value="template-03">Dragon Rider Caricature (GoT)</option>
            </select>
        </div>

        <!-- Gender Selection (for Raincrest templates) -->
        <div class="form-group" id="genderGroup">
            <label>üëë Character Type</label>
            <select id="genderSelect">
                <option value="couple">Couple (King & Queen)</option>
                <option value="king">Solo: King (Male)</option>
                <option value="queen">Solo: Queen (Female)</option>
            </select>
        </div>

        <!-- Generate Button -->
        <button id="generateBtn" disabled>‚ú® Generate Image</button>

        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p id="loadingText">Processing...</p>
        </div>

        <!-- Result -->
        <div class="result" id="result">
            <h3>‚úÖ Result</h3>
            <img id="resultImg" alt="Generated Image">
            <p id="resultInfo"></p>
        </div>

        <!-- Log -->
        <div class="log" id="log"></div>
    </div>

    <script>
        let selectedApi = 'replicate';
        let selectedFile = null;

        // API selection
        document.querySelectorAll('.api-option').forEach(el => {
            el.addEventListener('click', () => {
                document.querySelectorAll('.api-option').forEach(e => e.classList.remove('selected'));
                el.classList.add('selected');
                selectedApi = el.dataset.api;
                log(`Selected API: ${selectedApi}`);
            });
        });

        // Image compression function
        async function compressImage(file, maxWidth = 1500, maxHeight = 1875, quality = 0.8) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // Calculate new dimensions
                        let width = img.width;
                        let height = img.height;

                        if (width > maxWidth) {
                            height = (height * maxWidth) / width;
                            width = maxWidth;
                        }
                        if (height > maxHeight) {
                            width = (width * maxHeight) / height;
                            height = maxHeight;
                        }

                        // Create canvas and draw resized image
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        // Convert to blob
                        canvas.toBlob((blob) => {
                            resolve(new File([blob], file.name.replace(/\.[^.]+$/, '.jpg'), { type: 'image/jpeg' }));
                        }, 'image/jpeg', quality);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // File input with compression
        document.getElementById('imageInput').addEventListener('change', async (e) => {
            const originalFile = e.target.files[0];
            if (originalFile) {
                log(`Original file: ${originalFile.name} (${(originalFile.size / 1024).toFixed(1)} KB)`);

                // Compress if larger than 2MB
                if (originalFile.size > 2 * 1024 * 1024) {
                    log('Compressing image...');
                    selectedFile = await compressImage(originalFile);
                    log(`Compressed: ${(selectedFile.size / 1024).toFixed(1)} KB`);
                } else {
                    selectedFile = originalFile;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('previewImg').src = e.target.result;
                    document.getElementById('preview').style.display = 'block';
                };
                reader.readAsDataURL(selectedFile);
                document.getElementById('generateBtn').disabled = false;
            }
        });

        // Generate
        document.getElementById('generateBtn').addEventListener('click', async () => {
            if (!selectedFile) return;

            const templateId = document.getElementById('templateSelect').value;
            const gender = document.getElementById('genderSelect').value;
            const isCouple = gender === 'couple';

            document.getElementById('generateBtn').disabled = true;
            document.getElementById('loading').classList.add('show');
            document.getElementById('result').classList.remove('show', 'error');

            try {
                log(`Starting generation with ${selectedApi}...`);
                const startTime = Date.now();

                // First, upload image to Bunny.net
                log('Getting upload token...');
                const filename = `test-${Date.now()}.jpg`;

                const tokenResponse = await fetch('/.netlify/functions/create-upload-token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename })
                });

                if (!tokenResponse.ok) {
                    throw new Error('Failed to get upload token');
                }

                const tokenData = await tokenResponse.json();
                log(`Token received, uploading to Bunny.net...`);

                // Upload to Bunny
                const uploadResponse = await fetch(tokenData.uploadUrl, {
                    method: 'PUT',
                    headers: {
                        'AccessKey': tokenData.apiKey,
                        'Content-Type': 'image/jpeg'
                    },
                    body: selectedFile
                });

                if (!uploadResponse.ok && uploadResponse.status !== 201) {
                    throw new Error(`Bunny upload failed: ${uploadResponse.status}`);
                }

                const imageUrl = tokenData.cdnUrl;
                log(`Image uploaded: ${imageUrl}`);

                // Wait for CDN propagation
                log('Waiting for CDN propagation...');
                await new Promise(r => setTimeout(r, 2000));

                let result;

                if (selectedApi === 'gemini') {
                    // Use Background Function (15 minute timeout!)
                    const jobId = `gemini-${Date.now()}`;
                    const outputFilename = `generated/${jobId}.jpg`;
                    const cdnUrl = `https://raincrest-cdn.b-cdn.net/${outputFilename}`;

                    log('Starting Gemini Background Function...');
                    document.getElementById('loadingText').textContent = 'Starting generation...';

                    // Call background function (returns 202 immediately)
                    const bgResponse = await fetch('/.netlify/functions/generate-image-gemini-background', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            imageUrl,
                            templateId,
                            isCouple,
                            gender,
                            jobId,
                            outputFilename
                        })
                    });

                    log(`Background function started (status: ${bgResponse.status})`);

                    // Poll for result
                    document.getElementById('loadingText').textContent = 'AI is generating...';
                    let attempts = 0;
                    const maxAttempts = 90; // 3 minutes

                    while (attempts < maxAttempts) {
                        await new Promise(r => setTimeout(r, 2000));
                        attempts++;

                        try {
                            const checkResponse = await fetch(cdnUrl, { method: 'HEAD' });
                            if (checkResponse.ok) {
                                log(`‚úÖ Image ready after ${attempts * 2}s`);
                                result = { success: true, imageUrl: cdnUrl };
                                break;
                            }
                        } catch (e) {
                            // Not ready yet
                        }

                        document.getElementById('loadingText').textContent = `Generating... (${attempts * 2}s)`;
                        if (attempts % 10 === 0) {
                            log(`Still generating... (${attempts * 2}s)`);
                        }
                    }

                    if (!result) {
                        throw new Error('Generation timed out');
                    }

                    log(`‚úÖ Gemini completed in ${((Date.now() - startTime) / 1000).toFixed(1)}s`);


                } else if (selectedApi === 'veo') {
                    // üé¨ VEO 3.1 VIDEO GENERATION
                    const jobId = `veo-${Date.now()}`;
                    const outputFilename = `videos/${jobId}.mp4`;
                    const cdnUrl = `https://raincrest-cdn.b-cdn.net/${outputFilename}`;

                    // First, we need a generated image to animate
                    log('Step 1: Generating image with Gemini...');
                    document.getElementById('loadingText').textContent = 'Creating base image...';

                    // Generate image first
                    const bgImageResponse = await fetch('/.netlify/functions/generate-image-gemini-background', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            imageUrl,
                            templateId,
                            isCouple,
                            gender,
                            jobId: `img-${jobId}`,
                            outputFilename: `generated/img-${jobId}.jpg`
                        })
                    });

                    log('Image generation started, waiting...');
                    const generatedImageUrl = `https://raincrest-cdn.b-cdn.net/generated/img-${jobId}.jpg`;

                    // Wait for image
                    let imageReady = false;
                    for (let i = 0; i < 90; i++) {  // 90 * 2s = 3 minutes
                        await new Promise(r => setTimeout(r, 2000));
                        try {
                            const check = await fetch(generatedImageUrl, { method: 'HEAD' });
                            if (check.ok) {
                                imageReady = true;
                                break;
                            }
                        } catch (e) { }
                        document.getElementById('loadingText').textContent = `Creating image... (${(i + 1) * 2}s)`;
                    }

                    if (!imageReady) {
                        throw new Error('Image generation timed out');
                    }

                    log('‚úÖ Image ready! Step 2: Generating video...');
                    document.getElementById('loadingText').textContent = 'Creating video (this takes 1-2 min)...';

                    // Dynamic video prompts per template - ALL include Raincrest logo
                    const logoInstruction = `IMPORTANT: Display "RAINCREST.ART" watermark in elegant golden medieval font in the bottom-right corner throughout the entire video. Semi-transparent but clearly visible.`;

                    const videoPrompts = {
                        'template-01': `The royal couple slowly turns their heads toward camera with piercing eyes. The King's cape billows dramatically in the wind. The Queen's crown jewels shimmer. Flickering torchlight casts dancing shadows. Medieval fantasy cinematic. Hyper-realistic character animation. ${logoInstruction}`,

                        'template-02': `The dragon rider sits atop a massive dragon. Suddenly the DRAGON OPENS ITS MOUTH and BREATHES ENORMOUS FLAMES directly at camera! The rider's hair and cape whip in the wind. Dramatic camera shake. Sparks and embers fill the air. Cinematic Game of Thrones style. ${logoInstruction}`,

                        'template-03': `Caricature style animation. The dragon rider grins mischievously. The cartoon dragon SNORTS FIRE from its nostrils playfully. Character does dramatic hand gesture. Dragon winks. Fun bouncy animation with magical sparkles. ${logoInstruction}`
                    };

                    const videoPrompt = videoPrompts[templateId] || videoPrompts['template-01'];

                    // Start video generation
                    const veoResponse = await fetch('/.netlify/functions/generate-video-veo-background', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            imageUrl: generatedImageUrl,
                            prompt: videoPrompt,
                            jobId,
                            outputFilename
                        })
                    });

                    log(`Video generation started (status: ${veoResponse.status})`);

                    // Poll for video
                    let attempts = 0;
                    const maxAttempts = 180; // 6 minutes

                    while (attempts < maxAttempts) {
                        await new Promise(r => setTimeout(r, 2000));
                        attempts++;

                        try {
                            const checkResponse = await fetch(cdnUrl, { method: 'HEAD' });
                            if (checkResponse.ok) {
                                log(`‚úÖ Video ready after ${attempts * 2}s`);
                                result = { success: true, videoUrl: cdnUrl, isVideo: true };
                                break;
                            }
                        } catch (e) { }

                        document.getElementById('loadingText').textContent = `Rendering video... (${attempts * 2}s)`;
                        if (attempts % 15 === 0) {
                            log(`Still rendering video... (${attempts * 2}s)`);
                        }
                    }

                    if (!result) {
                        throw new Error('Video generation timed out');
                    }

                    log(`‚úÖ Video completed in ${((Date.now() - startTime) / 1000).toFixed(1)}s`);

                } else {
                    // Call Replicate API (async pattern)
                    log('Calling Replicate API...');
                    document.getElementById('loadingText').textContent = 'Starting Replicate...';

                    const startResponse = await fetch('/.netlify/functions/verify-and-start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            imageUrl,
                            templateId,
                            isCouple,
                            gender
                        })
                    });

                    const startResult = await startResponse.json();

                    if (!startResult.success) {
                        throw new Error(startResult.error || 'Failed to start Replicate');
                    }

                    const predictionId = startResult.predictionId;
                    log(`Prediction started: ${predictionId}`);

                    // Poll for result
                    document.getElementById('loadingText').textContent = 'AI is generating...';

                    let attempts = 0;
                    const maxAttempts = 60; // 2 minutes max

                    while (attempts < maxAttempts) {
                        await new Promise(r => setTimeout(r, 2000));
                        attempts++;

                        log(`Checking status (attempt ${attempts})...`);

                        const statusResponse = await fetch(`/.netlify/functions/check-status?predictionId=${predictionId}`);
                        const statusResult = await statusResponse.json();

                        if (statusResult.status === 'succeeded' && statusResult.imageUrl) {
                            result = { success: true, imageUrl: statusResult.imageUrl };
                            break;
                        } else if (statusResult.status === 'failed') {
                            throw new Error(statusResult.error || 'Replicate generation failed');
                        }

                        document.getElementById('loadingText').textContent = `Processing... (${attempts * 2}s)`;
                    }

                    if (!result) {
                        throw new Error('Timeout: Generation took too long');
                    }

                    log(`‚úÖ Replicate completed in ${((Date.now() - startTime) / 1000).toFixed(1)}s`);
                }

                // Show result
                if (result.isVideo) {
                    // Show video
                    document.getElementById('resultImg').style.display = 'none';
                    let videoEl = document.getElementById('resultVideo');
                    if (!videoEl) {
                        videoEl = document.createElement('video');
                        videoEl.id = 'resultVideo';
                        videoEl.controls = true;
                        videoEl.autoplay = true;
                        videoEl.loop = true;
                        videoEl.style.maxWidth = '100%';
                        videoEl.style.borderRadius = '10px';
                        document.getElementById('resultImg').parentNode.insertBefore(videoEl, document.getElementById('resultImg'));
                    }
                    videoEl.src = result.videoUrl;
                    videoEl.style.display = 'block';
                    document.getElementById('resultInfo').textContent = `üé¨ VIDEO | Source: ${selectedApi} | Time: ${((Date.now() - startTime) / 1000).toFixed(1)}s`;
                } else {
                    // Show image
                    let videoEl = document.getElementById('resultVideo');
                    if (videoEl) videoEl.style.display = 'none';
                    document.getElementById('resultImg').style.display = 'block';
                    document.getElementById('resultImg').src = result.imageUrl;
                    document.getElementById('resultInfo').textContent = `Source: ${selectedApi} | Time: ${((Date.now() - startTime) / 1000).toFixed(1)}s`;
                }
                document.getElementById('result').classList.remove('error');
                document.getElementById('result').classList.add('show');

            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                document.getElementById('result').classList.add('show', 'error');
                document.getElementById('resultInfo').textContent = `Error: ${error.message}`;
                document.getElementById('resultImg').style.display = 'none';
            } finally {
                document.getElementById('loading').classList.remove('show');
                document.getElementById('generateBtn').disabled = false;
            }
        });

        function log(message) {
            const logEl = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logEl.textContent += `[${time}] ${message}\n`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }

        log('Test page loaded. Select an image to begin.');
    </script>
</body>

</html>